<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Серии Лаймана, Бальмера, Пашена — модель Бора (поглощение/испускание)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background:#0b0f18; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #wrap { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    header {
      display:flex; flex-wrap:wrap; gap:10px; align-items:center;
      padding:10px 12px; background:rgba(255,255,255,0.04); border-bottom:1px solid rgba(255,255,255,0.08);
    }
    header .group { display:flex; gap:8px; align-items:center; padding:6px 8px; border-radius:10px; background:rgba(255,255,255,0.04); }
    label { font-size: 13px; opacity: 0.9; }
    select, input[type="range"], button {
      background:rgba(255,255,255,0.06); color:#e7ecff; border:1px solid rgba(255,255,255,0.12);
      border-radius:10px; padding:8px 10px; font-size: 13px;
    }
    input[type="range"]{ padding:0; height: 34px; }
    button { cursor:pointer; }
    button:hover { background:rgba(255,255,255,0.10); }
    #info { margin-left:auto; font-size:13px; opacity:0.9; }
    #info b { opacity:1; }
    canvas { width:100%; height:100%; display:block; }
    .hint { opacity: 0.75; font-size: 12px; }
  </style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="group">
      <label for="series">Серия</label>
      <select id="series">
        <option value="Lyman">Лаймана (n→1, UV)</option>
        <option value="Balmer" selected>Бальмера (n→2, видимый)</option>
        <option value="Paschen">Пашена (n→3, IR)</option>
      </select>
    </div>

    <div class="group">
      <label for="mode">Процесс</label>
      <select id="mode">
        <option value="Emission" selected>Испускание (вниз)</option>
        <option value="Absorption">Поглощение (вверх)</option>
      </select>
    </div>

    <div class="group">
      <label for="upperN">Верхний уровень n₂</label>
      <input id="upperN" type="range" min="2" max="8" step="1" value="5" />
      <span id="upperNVal" style="min-width:18px; text-align:right; display:inline-block;">5</span>
    </div>

    <div class="group">
      <label for="speed">Скорость</label>
      <input id="speed" type="range" min="0.4" max="2.0" step="0.1" value="1.0" />
      <span id="speedVal" style="min-width:34px; text-align:right; display:inline-block;">1.0×</span>
    </div>

    <div class="group">
      <button id="stepBtn">Сделать переход</button>
      <button id="autoBtn">Авто: выкл</button>
    </div>

    <div id="info">
      <div><b id="lineLabel">—</b></div>
      <div class="hint">Колесо мыши / трекпад: зум не нужен — просто смотри :)</div>
    </div>
  </header>

  <canvas id="c"></canvas>
</div>

<script>
(() => {
  // ======== ФИЗИКА (упрощённо, модель Бора) ========
  // Формула Ридберга:
  // 1/λ = R * (1/n1^2 - 1/n2^2), где n2 > n1
  const R = 1.0973731568508e7; // 1/м (константа Ридберга для водорода, достаточно точно для визуализации)
  const NM = 1e9;

  const SERIES_TO_N1 = { Lyman: 1, Balmer: 2, Paschen: 3 };
  const SERIES_META = {
    Lyman:   { name: "Лаймана",  band: "ультрафиолет", tag: "UV" },
    Balmer:  { name: "Бальмера", band: "видимый",      tag: "VIS" },
    Paschen: { name: "Пашена",   band: "инфракрасный",  tag: "IR" }
  };

  function wavelength_nm(n1, n2) {
    const inv = R * (1/(n1*n1) - 1/(n2*n2));
    const lambda_m = 1 / inv;
    return lambda_m * NM;
  }

  // Примерная конвертация длины волны (нм) в RGB (для видимого диапазона).
  // Для UV/IR делаем условные цвета (фиолетовый/красный + подпись).
  function wavelengthToRGB(lam) {
    // Dan Bruton-style approx (простая и популярная)
    let r=0,g=0,b=0;
    if (lam >= 380 && lam < 440) { r = -(lam-440)/(440-380); g = 0; b = 1; }
    else if (lam < 490)          { r = 0; g = (lam-440)/(490-440); b = 1; }
    else if (lam < 510)          { r = 0; g = 1; b = -(lam-510)/(510-490); }
    else if (lam < 580)          { r = (lam-510)/(580-510); g = 1; b = 0; }
    else if (lam < 645)          { r = 1; g = -(lam-645)/(645-580); b = 0; }
    else if (lam <= 750)         { r = 1; g = 0; b = 0; }

    // интенсивность на краях видимого
    let f = 0;
    if (lam >= 380 && lam < 420) f = 0.3 + 0.7*(lam-380)/(420-380);
    else if (lam <= 700)         f = 1.0;
    else if (lam <= 750)         f = 0.3 + 0.7*(750-lam)/(750-700);
    else                         f = 0.0;

    const gamma = 0.8;
    const to255 = (x) => Math.max(0, Math.min(255, Math.round(255*Math.pow(x*f, gamma))));
    return { r: to255(r), g: to255(g), b: to255(b), visible: (lam>=380 && lam<=750) };
  }

  function rgba({r,g,b}, a) { return `rgba(${r},${g},${b},${a})`; }

  // ======== UI ========
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const seriesSel = document.getElementById('series');
  const modeSel = document.getElementById('mode');
  const upperN = document.getElementById('upperN');
  const upperNVal = document.getElementById('upperNVal');
  const speedRange = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const stepBtn = document.getElementById('stepBtn');
  const autoBtn = document.getElementById('autoBtn');
  const lineLabel = document.getElementById('lineLabel');

  let DPR = 1;
  function resize() {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = canvas.clientWidth, h = canvas.clientHeight;
    canvas.width = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
  }
  window.addEventListener('resize', resize);
  resize();

  // ======== СЦЕНА ========
  let state = {
    series: seriesSel.value,
    mode: modeSel.value,
    n1: SERIES_TO_N1[seriesSel.value],
    n2: +upperN.value,
    speed: +speedRange.value,
    auto: false
  };

  // Геометрия (масштабируем орбиты ~ n^2)
  const maxN = 8;
  const electronTrail = [];   // последние позиции электрона
  const photonTrail = [];     // след волны фотона (точки)
  const MAX_E_TRAIL = 80;
  const MAX_P_TRAIL = 140;

  // Электрон
  const electron = {
    angle: 0,
    level: state.mode === "Emission" ? state.n2 : state.n1,
    levelFrom: null,
    levelTo: null,
    t: 0,
    transitioning: false
  };

  // Фотон
  const photon = {
    active: false,
    x: 0, y: 0,
    vx: 0, vy: 0,
    lam: 0,   // nm
    color: {r:255,g:255,b:255},
    mode: "Emission", // или Absorption
    arrived: false
  };

  function center() {
    return { cx: canvas.width*0.40, cy: canvas.height*0.52 };
  }

  function orbitRadius(n) {
    // r ~ n^2 (Бор)
    const { cx, cy } = center();
    const margin = Math.min(canvas.width, canvas.height) * 0.08;
    const maxR = Math.min(canvas.width, canvas.height) * 0.36 - margin;
    const base = maxR / (maxN*maxN);
    return base * n*n;
  }

  function setInfoLabel(n1, n2, lam) {
    const meta = SERIES_META[state.series];
    const band = (lam < 380) ? "UV" : (lam > 750 ? "IR" : "VIS");
    const bandText = band === "VIS" ? "видимый" : (band === "UV" ? "ультрафиолет" : "инфракрасный");
    lineLabel.textContent =
      `${meta.name}: ${state.mode === "Emission" ? "испускание" : "поглощение"}  ` +
      `n₂=${n2} → n₁=${n1}   λ≈${lam.toFixed(1)} нм (${bandText})`;
  }

  function syncStateFromUI() {
    state.series = seriesSel.value;
    state.mode = modeSel.value;
    state.n1 = SERIES_TO_N1[state.series];

    // гарантируем n2 > n1
    const minUpper = Math.max(state.n1 + 1, 2);
    upperN.min = String(minUpper);
    if (+upperN.value < minUpper) upperN.value = String(minUpper);

    state.n2 = +upperN.value;
    state.speed = +speedRange.value;

    upperNVal.textContent = state.n2;
    speedVal.textContent = state.speed.toFixed(1) + "×";

    // Если меняли режим/серию — поставим электрон на “правильный” стартовый уровень
    if (!electron.transitioning && !photon.active) {
      electron.level = (state.mode === "Emission") ? state.n2 : state.n1;
      electronTrail.length = 0;
      photonTrail.length = 0;
    }

    const lam = wavelength_nm(state.n1, state.n2);
    setInfoLabel(state.n1, state.n2, lam);
  }

  seriesSel.addEventListener('change', () => { syncStateFromUI(); });
  modeSel.addEventListener('change', () => { syncStateFromUI(); });
  upperN.addEventListener('input', () => { syncStateFromUI(); });
  speedRange.addEventListener('input', () => { syncStateFromUI(); });

  // ======== ПЕРЕХОДЫ ========
  function startTransition(fromN, toN) {
    electron.levelFrom = fromN;
    electron.levelTo = toN;
    electron.t = 0;
    electron.transitioning = true;
  }

  function spawnPhotonForTransition(n1, n2) {
    const lam = wavelength_nm(n1, n2);
    const col = wavelengthToRGB(lam);
    const { cx, cy } = center();

    photon.lam = lam;
    photon.color = col.visible ? col : (lam < 380 ? {r:150,g:120,b:255} : {r:255,g:120,b:80}); // условные UV/IR
    photon.mode = state.mode;
    photon.arrived = false;
    photonTrail.length = 0;

    // Направление
    if (state.mode === "Emission") {
      // из центра наружу
      const ang = electron.angle + Math.PI * 0.25;
      const speed = 520 * DPR * state.speed;
      photon.x = cx;
      photon.y = cy;
      photon.vx = Math.cos(ang) * speed;
      photon.vy = Math.sin(ang) * speed;
    } else {
      // снаружи к центру
      const ang = electron.angle + Math.PI * 0.25;
      const speed = 520 * DPR * state.speed;
      const dist = Math.min(canvas.width, canvas.height) * 0.55;
      photon.x = cx + Math.cos(ang) * dist;
      photon.y = cy + Math.sin(ang) * dist;
      photon.vx = -Math.cos(ang) * speed;
      photon.vy = -Math.sin(ang) * speed;
    }

    photon.active = true;
    setInfoLabel(n1, n2, lam);
  }

  function doOneStep() {
    syncStateFromUI();

    const n1 = state.n1;
    const n2 = state.n2;

    if (state.mode === "Emission") {
      // Электрон сначала на n2, затем падает на n1 и испускает фотон
      electron.level = n2;
      startTransition(n2, n1);
      spawnPhotonForTransition(n1, n2); // длина волны зависит от пары (n1,n2)
    } else {
      // Поглощение: сначала фотон летит к центру; когда "впитается" — электрон поднимется
      electron.level = n1;
      // переход начнём когда фотон долетит
      spawnPhotonForTransition(n1, n2);
    }
  }

  stepBtn.addEventListener('click', doOneStep);

  autoBtn.addEventListener('click', () => {
    state.auto = !state.auto;
    autoBtn.textContent = `Авто: ${state.auto ? "вкл" : "выкл"}`;
  });

  // ======== РЕНДЕР ========
  function drawBackground() {
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    // мягкий градиент
    const g = ctx.createRadialGradient(w*0.40, h*0.55, 10, w*0.40, h*0.55, Math.max(w,h)*0.8);
    g.addColorStop(0, "rgba(120,160,255,0.10)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
  }

  function drawOrbits() {
    const { cx, cy } = center();

    // ядро
    ctx.beginPath();
    ctx.arc(cx, cy, 7*DPR, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.fill();

    // кольца орбит
    for (let n=1; n<=maxN; n++) {
      const r = orbitRadius(n);
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI*2);
      ctx.strokeStyle = (n === state.n1) ? "rgba(255,255,255,0.28)" : "rgba(255,255,255,0.12)";
      ctx.lineWidth = (n === state.n1) ? 2*DPR : 1*DPR;
      ctx.stroke();

      // подписи n
      const tx = cx + r + 10*DPR;
      const ty = cy - 2*DPR;
      ctx.fillStyle = "rgba(255,255,255,0.45)";
      ctx.font = `${12*DPR}px system-ui`;
      ctx.fillText(`n=${n}`, tx, ty);
    }
  }

  function drawEnergyLadder() {
    // справа — лестница уровней энергии (условная)
    const w = canvas.width, h = canvas.height;
    const x0 = w * 0.72;
    const y0 = h * 0.20;
    const y1 = h * 0.86;

    // фон панели
    ctx.fillStyle = "rgba(255,255,255,0.03)";
    ctx.fillRect(x0 - 18*DPR, y0 - 18*DPR, w - x0 + 8*DPR, (y1 - y0) + 26*DPR);

    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1*DPR;
    ctx.strokeRect(x0 - 18*DPR, y0 - 18*DPR, w - x0 + 8*DPR, (y1 - y0) + 26*DPR);

    // линии уровней: чем больше n, тем ближе друг к другу (энергии сближаются)
    function yForN(n) {
      // Е ~ -1/n^2 -> визуально: используем 1/n^2, чтобы сверху (n=1) был “глубже”
      const t = (1/(n*n) - 1/(maxN*maxN)) / (1 - 1/(maxN*maxN)); // 0..1
      return y1 - t * (y1 - y0);
    }

    // заголовок
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.font = `${13*DPR}px system-ui`;
    ctx.fillText("Энергетические уровни (условно)", x0, y0 - 26*DPR);

    for (let n=1; n<=maxN; n++) {
      const y = yForN(n);
      ctx.beginPath();
      ctx.moveTo(x0, y);
      ctx.lineTo(w - 20*DPR, y);
      const hi = (n === state.n1) || (n === state.n2);
      ctx.strokeStyle = hi ? "rgba(255,255,255,0.22)" : "rgba(255,255,255,0.10)";
      ctx.lineWidth = hi ? 2*DPR : 1*DPR;
      ctx.stroke();

      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.font = `${12*DPR}px system-ui`;
      ctx.fillText(`n=${n}`, x0 - 42*DPR, y + 4*DPR);
    }

    // маркер текущего положения электрона на лестнице
    const eN = electron.level;
    const yE = yForN(eN);
    ctx.beginPath();
    ctx.arc(x0 - 10*DPR, yE, 5*DPR, 0, Math.PI*2);
    ctx.fillStyle = "rgba(180,220,255,0.95)";
    ctx.fill();

    // подпись режима
    const meta = SERIES_META[state.series];
    ctx.fillStyle = "rgba(255,255,255,0.65)";
    ctx.font = `${12*DPR}px system-ui`;
    ctx.fillText(`${meta.name}: n→${state.n1} (${meta.tag})`, x0, y1 + 18*DPR);
  }

  function drawSpectrumBar() {
    // снизу — полоска спектра с линиями для выбранной серии
    const w = canvas.width, h = canvas.height;
    const x0 = w * 0.10;
    const x1 = w * 0.68;
    const y0 = h * 0.90;
    const hh = 26*DPR;

    // диапазон по λ: возьмём 90..2000 нм, лог шкала (чтобы UV/IR не “убежали”)
    const LMIN = 90, LMAX = 2000;
    const log = (x) => Math.log(x);
    const mapX = (lam) => {
      const t = (log(lam) - log(LMIN)) / (log(LMAX) - log(LMIN));
      return x0 + t * (x1 - x0);
    };

    // рамка
    ctx.fillStyle = "rgba(255,255,255,0.03)";
    ctx.fillRect(x0, y0, x1-x0, hh);
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.strokeRect(x0, y0, x1-x0, hh);

    // подписи
    ctx.fillStyle = "rgba(255,255,255,0.6)";
    ctx.font = `${12*DPR}px system-ui`;
    ctx.fillText("Спектральные линии (лог шкала λ)", x0, y0 - 10*DPR);

    // отметки: 100, 200, 400, 800, 1600
    const ticks = [100,200,400,800,1600];
    for (const t of ticks) {
      const x = mapX(t);
      ctx.beginPath();
      ctx.moveTo(x, y0+hh);
      ctx.lineTo(x, y0+hh+8*DPR);
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 1*DPR;
      ctx.stroke();
      ctx.fillStyle = "rgba(255,255,255,0.45)";
      ctx.font = `${11*DPR}px system-ui`;
      ctx.fillText(`${t}нм`, x-12*DPR, y0+hh+20*DPR);
    }

    // линии серии: n2 = n1+1..maxN
    const n1 = state.n1;
    for (let n2 = n1+1; n2<=maxN; n2++) {
      const lam = wavelength_nm(n1, n2);
      const col = wavelengthToRGB(lam);
      const x = mapX(Math.max(LMIN, Math.min(LMAX, lam)));

      ctx.beginPath();
      ctx.moveTo(x, y0);
      ctx.lineTo(x, y0+hh);

      let stroke = col.visible ? rgba(col, 0.9) : (lam < 380 ? "rgba(160,130,255,0.85)" : "rgba(255,140,90,0.85)");
      ctx.strokeStyle = stroke;
      ctx.lineWidth = (n2 === state.n2) ? 3*DPR : 2*DPR;
      ctx.stroke();
    }

    // маркер текущей линии
    const lamNow = wavelength_nm(state.n1, state.n2);
    const xNow = mapX(Math.max(LMIN, Math.min(LMAX, lamNow)));
    ctx.beginPath();
    ctx.arc(xNow, y0-6*DPR, 4*DPR, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.8)";
    ctx.fill();
  }

  function drawElectron() {
    const { cx, cy } = center();
    const r = orbitRadius(electron.level);

    // позиция электрона
    const ex = cx + Math.cos(electron.angle) * r;
    const ey = cy + Math.sin(electron.angle) * r;

    // хвост электрона
    electronTrail.push({x:ex, y:ey});
    while (electronTrail.length > MAX_E_TRAIL) electronTrail.shift();

    ctx.lineWidth = 2*DPR;
    for (let i=1; i<electronTrail.length; i++) {
      const a = i / electronTrail.length;
      ctx.strokeStyle = `rgba(120,200,255,${0.35*a})`;
      ctx.beginPath();
      ctx.moveTo(electronTrail[i-1].x, electronTrail[i-1].y);
      ctx.lineTo(electronTrail[i].x, electronTrail[i].y);
      ctx.stroke();
    }

    // сам электрон
    ctx.beginPath();
    ctx.arc(ex, ey, 5.5*DPR, 0, Math.PI*2);
    ctx.fillStyle = "rgba(170,230,255,0.95)";
    ctx.fill();

    // подсветка при переходе (радиальный “шлейф” между орбитами)
    if (electron.transitioning && electron.levelFrom != null && electron.levelTo != null) {
      const r0 = orbitRadius(electron.levelFrom);
      const r1 = orbitRadius(electron.levelTo);
      const rr = Math.abs(r1 - r0);
      const mid = Math.min(r0,r1) + rr/2;

      const gx = cx + Math.cos(electron.angle) * mid;
      const gy = cy + Math.sin(electron.angle) * mid;

      const grad = ctx.createRadialGradient(gx, gy, 2*DPR, gx, gy, rr + 18*DPR);
      grad.addColorStop(0, "rgba(120,200,255,0.22)");
      grad.addColorStop(1, "rgba(120,200,255,0)");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(gx, gy, rr + 18*DPR, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawPhoton() {
    if (!photon.active) return;

    // след фотона как “волна” (синус вдоль направления движения)
    photonTrail.push({x:photon.x, y:photon.y});
    while (photonTrail.length > MAX_P_TRAIL) photonTrail.shift();

    // нарисуем хвост волны: по последним точкам, с лёгким смещением по синусу
    const col = photon.color;
    const tailAlpha = 0.55;

    // направление движения нормализованное
    const vlen = Math.hypot(photon.vx, photon.vy) || 1;
    const ux = photon.vx / vlen, uy = photon.vy / vlen;
    // перпендикуляр (для “волнистости”)
    const px = -uy, py = ux;

    // длина волны влияет на “частоту волны” в хвосте: чем меньше λ, тем быстрее колебания
    const freq = 2*Math.PI / Math.max(16, Math.min(90, photon.lam * 0.12)); // пиксели на период (условно)
    const amp = 6*DPR;

    ctx.lineWidth = 2*DPR;

    for (let i=1; i<photonTrail.length; i++) {
      const t = i / photonTrail.length; // 0..1
      const a = tailAlpha * t;

      const p0 = photonTrail[i-1];
      const p1 = photonTrail[i];

      // добавим синусоидальное смещение в поперечном направлении
      const phase0 = i * 3.2;
      const phase1 = (i+1) * 3.2;
      const w0 = Math.sin(phase0 * freq) * amp * t;
      const w1 = Math.sin(phase1 * freq) * amp * t;

      ctx.strokeStyle = rgba(col, a);

      ctx.beginPath();
      ctx.moveTo(p0.x + px*w0, p0.y + py*w0);
      ctx.lineTo(p1.x + px*w1, p1.y + py*w1);
      ctx.stroke();
    }

    // сам фотон “шариком”
    ctx.beginPath();
    ctx.arc(photon.x, photon.y, 4.5*DPR, 0, Math.PI*2);
    ctx.fillStyle = rgba(col, 0.95);
    ctx.fill();

    // маленькая подпись UV/IR если не видно
    if (!(wavelengthToRGB(photon.lam).visible)) {
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.font = `${12*DPR}px system-ui`;
      const tag = photon.lam < 380 ? "UV" : "IR";
      ctx.fillText(tag, photon.x + 8*DPR, photon.y - 8*DPR);
    }
  }

  // ======== ОБНОВЛЕНИЕ ========
  let last = performance.now();
  let autoTimer = 0;

  function update(dt) {
    // вращение электрона
    const baseOmega = 1.25; // рад/сек
    electron.angle += baseOmega * dt * state.speed;
    if (electron.angle > Math.PI*2) electron.angle -= Math.PI*2;

    // анимация перехода по уровням
    if (electron.transitioning) {
      electron.t += dt * 1.2 * state.speed; // скорость перехода
      const t = Math.min(1, electron.t);
      // плавность
      const s = t*t*(3 - 2*t);
      electron.level = electron.levelFrom + (electron.levelTo - electron.levelFrom) * s;

      if (t >= 1) {
        electron.transitioning = false;
        electron.level = electron.levelTo;
      }
    }

    // движение фотона
    if (photon.active) {
      photon.x += photon.vx * dt;
      photon.y += photon.vy * dt;

      const { cx, cy } = center();
      const distToCenter = Math.hypot(photon.x - cx, photon.y - cy);

      // если поглощение: когда фотон "доехал" до центра — запускаем подъём электрона
      if (state.mode === "Absorption" && !photon.arrived) {
        if (distToCenter < 10*DPR) {
          photon.arrived = true;
          photon.active = false;
          photonTrail.length = 0;
          startTransition(state.n1, state.n2);
        }
      }

      // если испускание: выключим фотон когда улетел далеко
      if (state.mode === "Emission") {
        const w = canvas.width, h = canvas.height;
        if (photon.x < -80*DPR || photon.y < -80*DPR || photon.x > w+80*DPR || photon.y > h+80*DPR) {
          photon.active = false;
          photonTrail.length = 0;
        }
      }
    }

    // авто-режим
    if (state.auto) {
      autoTimer += dt;
      // каждые ~2.2 секунды — новый переход, если нет активной анимации
      if (autoTimer > 2.2 / Math.max(0.5, state.speed)) {
        autoTimer = 0;
        if (!electron.transitioning && !photon.active) {
          // можно иногда менять n2
          const n1 = state.n1;
          const n2 = n1 + 1 + Math.floor(Math.random() * Math.max(1, (maxN - (n1+1) + 1)));
          upperN.value = String(n2);
          syncStateFromUI();
          doOneStep();
        }
      }
    }
  }

  function render() {
    drawBackground();
    drawOrbits();
    drawElectron();
    drawPhoton();
    drawSpectrumBar();
    drawEnergyLadder();

    // подсказка по управлению
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.font = `${12*DPR}px system-ui`;
    const x = canvas.width*0.10, y = canvas.height*0.08;
    ctx.fillText("", x, y);
  }

  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    update(dt);
    render();

    requestAnimationFrame(loop);
  }

  // старт
  syncStateFromUI();
  setInfoLabel(state.n1, state.n2, wavelength_nm(state.n1, state.n2));
  requestAnimationFrame(loop);

  // по умолчанию: один шаг после загрузки (чтобы сразу было красиво)
  setTimeout(() => { doOneStep(); }, 350);
})();
</script>
</body>
</html>
